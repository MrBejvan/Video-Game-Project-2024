# Video Game Project 2024
 "Simple" Video Game Project

Data Structure Implemented: Sorted Circular Linked List
Additional Structure Implemented: Map
Presentation: Free Form Video Presentation with Thorough Code Tracing

Quick note on video presentation and a thank you: This video is very in depth and I have edited it as best as I could. However, there is just a ton of content that I worked very hard on and wanted to cover for this project. If desired or necessary I can re-record this in a more condensed format. Please reach out via email if this is requested, and thank you so much for the opportunity to learn in your classroom.

Project Overview: This project began as a personal project a few weeks before the project proposal was due because I wanted a relatable but challenging programming problem to work on that could be used as the base for my Data Structures project. It was quite challenging to learn a new language just for this project, but the format of a game was easily understandable to me and helped facilitate the learning process. I created all of the art and scripting for the current implementation of this project with the help and inspiration from several YouTube channels that I will list below. Additionally, Reddit forums for GODOT, as well as StackOverflow, were incredibly helpful at my most challenging points. Personally, the biggest challenge for this project was to build it in such a way that code could be re-used easily and specific data could be accessed through resource files instead of directly built-in scripts, which would have taken so much longer to create. Getting all of the files to correctly communicate with each other was an amazing challenge and I spent much of my time just trying to figure that out. But once I had it set up correctly, I was able to implement my turnTracker and sceneNavigation features very easily and I have a stable skeleton for scripting that I can essentially copy-paste to other parts of my game.

The main data structure that I implemented is a single-link, sorted, circular linked list. The function of this data structure is to operate as a turn tracker for a simple video game. GDscript is a pointerless language, similar to Python, so to build the data structure I had to create a Class called CharacterNode with properties that included a 'nextUp' value where I stored the next CharacterNode. This functioned as the link between nodes in the list. Practically, this data structure was built in such a way as to dynamically collect character nodes and their relevant ability scores, sort the characters based on those scores, and then return a re-linked circular list. Currently, there are no mechanics for updating a character's health bar, which will ultimately trigger a 'death' mechanic and the subsequent removal of the character from the circular linked list. However, I built a 'killButton' which is designed to randomly remove a character from the linked list via a random integer generated and modified with the modulo operator. This was built to demonstrate the functionality of the circular linked list and will later be used to implement the 'death' mechanic as mentioned before once additional combat actions are set up.

The sorting algorithm for the circular linked list is very simple; using each character's swift ability score it places the highest value as the head of the list, and the head of the linked list's 'nextUp' property is set to the character node with the next highest swift ability score, and the process is repeated until the 'head' is reached again. For tie-breakers, the current implementation simply sets the character node first encountered during the sorting function ahead of the other characters with the same score. Future implementation will involve taking all of the character nodes with the same 'swift' score and assigning each of them a random integer between 1 and 20, then assigning them to the turnTracker in that order.

The additional data structure that was implemented was a map/associative array. This is a built-in feature of the game engine, but I used it to great effect for scene navigation from the WorldMap scene. I built a dictionary with key-value pairs, where the keys were simple scene titles and the values were the relevant scene file paths. This allowed me to compartmentalize the scene directory and keep it separate from the rest of the world map scripting while also letting me grab the path values with simple keys that were set into 2d Collision Shapes on my WorldMap. When the player icon collided with these collision shapes, a signal containing the key would be sent to the WorldMap script which would then translate the key to the value pair. Once translated, this path value would then be used to update a button, which upon being pressed, would execute a scene transition to that particular level. I am not sure if this is exactly worth mentioning since it was a built-in feature and I did not modify the data structure much from what we practiced in class conceptually. However, getting many different file paths set to work properly based on their keys, along with the signaling and file communication to do so, was very challenging and I consider what I learned extremely valuable, not only in terms of building a functional program, but also in terms of organizing a project and all of its subsequent parts.

YouTube channels: GDQuest, DevWorm, CoCoCode, 16BitDev, GWizz, Queble, GameDevKnight

Video Presentation Link: https://youtu.be/eTUgiR6pu04?si=FLXuEm-HPfysXNUe
 
Concise Explanation of Project and Walk-Through of Key Functions and Structures:
For this project I implemented a sorted circular linked list to operate as a turn tracker for my video game project. The dynamic nature of the circular linked list allows for characters to be easily added and removed based on their character data, which creates a lot of flexibility for the game and was a big reason why I selected this data structure for my project. The list is sorted based on character data, and the sorting algorithm used is essentially a bubble sort. The character data is pulled from resource files through script files that I have constructed to be very dynamic.  This is important for me because, although the game is very simple right now, I may decide to implement more characters for the player to control as well as incorporate enemy characters that appear part way through the battle levels for added difficulty. 
	Additionally, I implemented a map data structure which contains key-value pairs for the level scene file paths. This information is also pulled dynamically upon collision events that occur when the character icon overlaps with the level nodes on the world map. In the long format video, I trace through all the code thoroughly. But here I will explain only how the insert, sort, and remove functions work without the information on how the data all connects. I will also show the map data structure and how that data is accessed upon the collision events. Then I will show off the game in its current form and functionality.

 -go to insert function-
This function is designed to create character class turn nodes from character data and add them to the circular linked list. Each node in the circular linked list has the essential property of nextUp which is designed to hold the next node in the list; this forms the links for the data structure. The function first checks if the list is empty and updates the head and current variables which are helpful for managing the data structure. If the list is not empty, then the function checks if the current node’s nextUp property is not equivalent to head and if the current node’s nextUp node’s swift score is less than the current node’s swift score. If not, then we move the current variable forward in the list by setting it to current.nextUp. Then we add the new character node to the list by assigning the current node’s nextUp property to the new node. This is designed in a way to reduce some of the time complexity that the bubble sort algorithm will experience. 
	
 -go to sort function-
This function, and its helper function, are designed using the bubble sort algorithm with a slight modification where the nodes to be sorted are pulled into an array for easier sorting and then relinked by updating the nextUp properties. Although the time complexity for this algorithm is not the most efficient, practically speaking it works just fine because in my current ideas for the game there would only ever be a max of 8- or 10-character nodes in any given combat scene at a time, so building an easily understandable algorithm was most important for me at the time of implementation.
	
 -go to remove function-
This function is currently designed to work with a button but will eventually be sewn into the battle mechanics with signals that transmit upon updates to character health values. By pressing the aggressively named ‘kill button’ a function will execute that randomly selects a character in the battle scene to be removed from the circular linked list. This function first checks if the list is empty, then if the head is the node that needs to be removed. If so, the head variable is updated to the next node in the linked list and the last node’s nextUp variable is set to the new head node. This effectively removes the initial head from the list. Otherwise, the function iterates through the linked list until the name matches the current node’s nextUp node’s name and then the current node’s nextUp is set to current’s nextUp nextUp’s node. The function then reprints the updated turn tracker.
	
 -go to Map- 
Here you can see the map with the keys and value pairs; note that the value pairs are file paths to each level scene. Using this structure is important because it compartmentalizes the scene names and respective paths from the rest of the scripting associated with the world map scene and makes it easy and centralized to update incase the file paths change with future development. The dynamic nature of the retrieval system is also important because it allows for very easy level building for future development too.
	
 -got to getPath-
	This is the function responsible for accessing the map data structure and obtaining the value pair. This function is setup to receive a signal from the specific Area2D node containing the unique scene name which functions as the key for the map data structure. This function then accesses the map and, using a built-in get function, retrieves the path string. The function then uses that string to update a variable in the fightButton which, on being pressed, then executes the scene change into that specific level.
	
Those are all the key features of the project. Challenges for this project included learning a new computer language. Even though it is similar to Python, I have loved C++ ever since I started learning it with 1300 and 2270 and making the switch was difficult at first. Additionally, building the data structures themselves was easy going compared to getting all of the different files and signals to properly communicate with each other. I spent most of my time just debugging that part of the project, but I also really appreciated the challenge that it brought and the things I learned about how to organize large projects.
